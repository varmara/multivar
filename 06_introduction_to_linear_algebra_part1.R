#' title: "Краткое введение в мир линейной алгебры. Часть 2"
#' subtitle: "Анализ и визуализация многомерных данных с использованием R"
#' author: Вадим Хайтов, Марина Варфоломеева

matrix(1:12, ncol = 3)

diag(rep(1, 5))


#' ##Транспонирование матриц
A <- matrix(1:12, ncol = 3)
A

B <- t(A)
B

#' ##Сложение матриц

A + 4

A + A

#' Но! Нельзя складывать матрицы разных размеров
A + B

#' ##Простое умножение

A * 4

#' Простое умножение матрицы на вектор возможно только если число элементов в векторе равно числу строк в матрице

A * c(10, 11, 12, 13)

#' Длина вектора

Vec <- 1:5

sqrt(sum(Vec^2))


norm(t(Vec), type = "F") #Аналогчное решение

#' ##  Скалярное произведение векторов

#'
#' В доме есть следующие электроприборы.
#'
#' Электроприбор | Количество | Мощность (Вт) |
#' --------------|------------|---------------|
#' Чайник        | 2 шт       |       1200    |
#' Обогреватели  | 3 шт.      |    1300       |
#' Осушитель     | 1 шт.      |     1100 |
#' Стиральная машина | 1 шт.| 1500 |
#' Фен | 2 шт. | 800 |
#'
#' Вопрос: Какова будет суммарная мощность всех электроприборов, если их включить одновременно?
#'
#' ## Решение

n <- c(2, 3, 1, 1, 2)
power <- c(1200, 1300, 1100, 1500, 800)


n %*% power





#' ## Задание
#'
#' Выясните, являются ли ортогональными следующие векторы?

a <- c(0, 1)
b <- c(1, 0)
c <- c(1, 1)
d <- c(1, -1)

#' Аналитическое решение



#' ## Нормализованные векторы
#' ##Задание
#' Найдите нормализованный вектор для следующего вектора и определите его длину

Vec <- 1:5
Vec

#' ##Решение





#' ## Матричное умножение матрицы на вектор {.smaller .columns-2}

#' Пусть, есть матрица
A
A %*% c(10, 10, 10)



#' Но! если поменять местами множители, то будет ошибка
c(10, 10, 10) %*% A



#' ## Матричное умножение вектора на матрицу

c(10, 10, 10, 10) %*% A

A %*% c(10, 10, 10, 10)



#' ##Умножение матриц {.smaller .columns-2}
A

B

B %*% A

A %*% A

B %*% t(B)



#'
#' ## Зачем это нужно?  {.smaller .columns-2}
#' ### Бытовой пример
#' Представим себе, что вы решили купить четыре товара, по следующим ценам
#'
#' Товар | Цена
#' ------|-----
#' Товар 1 | 10
#' Товар 2 | 20
#' Товар 3 | 30
#' Товар 4 | 40
#'
#'
#'
#' Прямых выходов на продавца у вас нет, но есть три посредника, которые выставляют следующие "накрутки" цен.
#'
#' Посредники  | Товар 1 | Товар 2 | Товар 3 | Товар 4
#' ------------|---------|---------|---------|--------
#' Посредник 1 | 0.1     | 0.15    | 0.05    | 0.05
#' Посредник 2 | 0.15    | 0.15    | 0.09    | 0.01
#' Посредник 3 | 0.2     | 0.05    | 0.1     | 0.1



# Какой из посредников выгоднее?
#' ## Решение

cost <- c(10, 20, 30, 40)

retailer <- matrix(c(0.1, 0.15, 0.05, 0.05,
                     0.15, 0.15, 0.09, 0.01,
                     0.2, 0.05, 0.1, 0.1 ), byrow = TRUE, ncol = 4)

cost %*% t(retailer)

retailer %*% cost


#' ## Матрицы позволяют преобразовывать системы векторов
#'
#' Начальная система расположения точек
#'



y = c(2,2,3,3,2,2,3,4,5,6,6,5,4,3,2)
x = c(2,3,4,5,6,7,7,7,6,5,4,3,2,2,2)

Image <- cbind((x), (y))

library(ggplot2)
qplot(Image[,1], Image[,2] ) + geom_polygon(fill = "red") + coord_fixed()


#' Поворот изображения на заданный угол

angle <- 45*pi/180

Rot <- matrix(c(cos(angle), sin(angle),
                -sin(angle), cos(angle)), nrow = 2)

Image_trans <-   t((Rot) %*% t(Image))


qplot(Image_trans[,1], Image_trans[,2] ) +
  geom_polygon(fill = "red") + coord_fixed()









#' Масштабирующая матрица
Scale <- matrix(c(1, 0, 0, 0.1), nrow = 2)

Image_trans2 <-   t((Scale) %*% t(Image_trans))

qplot(Image_trans2[,1], Image_trans2[,2] ) +
  geom_polygon(fill = "red") + coord_fixed()




#####################################################
# Работа с изобажениями, как с матричными объектами #
#####################################################


load("data/face.rda")

faceData
dim(faceData)

library(reshape2)

faceData_XY <- melt(faceData) ## Переводим матрицу в два вектора координат и вектор значений интенсивности заливки

names(faceData_XY) <- c("X1", "X2", "value")


ggplot(faceData_XY, aes(X1, X2)) + geom_tile(aes(fill = value)) + scale_fill_gradient(low = "darkblue",   high =  "white" ) + coord_equal()


################## Поворот изображения ##########################3

# Задание: Поверните изображение на угол 30 и 90 градусов


angle  #Задаем угол поворота в радианах

# Вращающая матрица
Rot <-

Image_rot <-   data.frame(t((  ) %*% t(   )), value = faceData_XY[3]) #Надо заполнить пропуски

ggplot(Image_rot, aes(X1, X2)) + geom_point(aes(color = value), size = 5) + scale_fill_gradient(low = "darkblue",   high =  "white" )


# Задание: Проведите масштабирование полученного изображения

Scale <- matrix(c(    ), nrow = 2)

Image_trans <-   data.frame(t((Scale) %*% t(Image_rot[,1:2])), value = faceData_XY$value)

ggplot(Image_trans, aes(X1, X2)) + geom_point(aes(color = value), size = 5) + scale_fill_gradient(low = "darkblue",   high =  "white" ) + coord_equal()



# Задание
# Загрузите матрицу, содержащую изображение
matr <- read.csv("data/a_matrix.csv")

# Визуализируйте эту матрицу в виде множества точек в двумерных координатах
#Произведите вращение и масштабирование этой матрицы



###############################################################
# Важные матрицы в многомерных методах
###############################################################





#' ## Ковариационная матрица

M <- matrix(c(1,2,3,4,5,5,2,1,2,5,2,1,3,5,4,6,8,4,0,2), ncol = 4)
M

#' Матрица центрированных значений
Cent_M <- scale(M, center = TRUE, scale = FALSE)
Cent_M

#' Вычислите ковариационную матрицу с помощью методов линейной алгебры и сравните ее с матрицей, полученной с помощью функции `cov()`

Cov_M <-     #код для вычислению ковариационной матрицы с помощью матричной алгебры

cov(M)

diag(Cov_M)

#' Сравним с результатами пименения функции sd()

apply(M, 2, FUN = function(x)sd(x)^2)

#' ## Вычисление матрицы  корреляций с помощью линейной алгебры {.smaller .columns-2}

Stand_M <- scale(  )
Stand_M


# Вычисление вручную
Cor_M <-



cor(M) # Стандартная функция R




